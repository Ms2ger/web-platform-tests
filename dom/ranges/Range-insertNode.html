<!doctype html>
<title>Range.insertNode() tests</title>
<link rel="author" title="Aryeh Gregor" href=ayg@aryeh.name>
<meta name=timeout content=long>
<p>To debug test failures, add a query parameter "subtest" with the test id (like
"?subtest=5,16").  Only that test will be run.  Then you can look at the resulting
iframes in the DOM.
<div id=log></div>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src=../common.js></script>
<script>
"use strict";

testDiv.parentNode.removeChild(testDiv);

function restoreIframe(iframe, i, j) {
    // Most of this function is designed to work around the fact that Opera
    // doesn't let you add a doctype to a document that no longer has one, in
    // any way I can figure out.  I eventually compromised on something that
    // will still let Opera pass most tests that don't actually involve
    // doctypes.
    while (iframe.contentDocument.firstChild
    && iframe.contentDocument.firstChild.nodeType != Node.DOCUMENT_TYPE_NODE) {
        iframe.contentDocument.removeChild(iframe.contentDocument.firstChild);
    }

    while (iframe.contentDocument.lastChild
    && iframe.contentDocument.lastChild.nodeType != Node.DOCUMENT_TYPE_NODE) {
        iframe.contentDocument.removeChild(iframe.contentDocument.lastChild);
    }

    if (!iframe.contentDocument.firstChild) {
        // This will throw an exception in Opera if we reach here, which is why
        // I try to avoid it.  It will never happen in a browser that obeys the
        // spec, so it's really just insurance.  I don't think it actually gets
        // hit by anything.
        iframe.contentDocument.appendChild(iframe.contentDocument.implementation.createDocumentType("html", "", ""));
    }
    iframe.contentDocument.appendChild(referenceDoc.documentElement.cloneNode(true));
    iframe.contentWindow.setupRangeTests();
    iframe.contentWindow.testRangeInput = testRangesShort[i];
    iframe.contentWindow.testNodeInput = testNodesShort[j];
    iframe.contentWindow.run();
}

function testInsertNode(i, j) {
    console.log("testInsertNode("+i+", "+j+")");
    var actualRange;
    var expectedRange;
    var actualNode;
    var expectedNode;
    var actualRoots = [];
    var expectedRoots = [];

    var detached = false;

    domTests[i][j].step(function() {
        restoreIframe(expectedIframe, i, j);
        expectedRange = expectedIframe.contentWindow.testRange;
        expectedNode = expectedIframe.contentWindow.testNode;
        console.log(expectedIframe.contentWindow.testRangeInput)
        console.log(expectedIframe.contentWindow.testNodeInput)

        myInsertNode(expectedRange, expectedNode)
    });
    domTests[i][j].done();

    positionTests[i][j].step(function() {
        assert_equals(actualIframe.contentWindow.unexpectedException, null,
            "Unexpected exception thrown when setting up Range for actual insertNode()");
        assert_equals(expectedIframe.contentWindow.unexpectedException, null,
            "Unexpected exception thrown when setting up Range for simulated insertNode()");
        assert_equals(typeof actualRange, "object",
            "typeof Range produced in actual iframe");
        assert_false(actualRange === null,
            "Range produced in actual iframe was null");
        assert_equals(typeof expectedRange, "object",
            "typeof Range produced in expected iframe");
        assert_false(expectedRange === null,
            "Range produced in expected iframe was null");
        assert_equals(typeof actualNode, "object",
            "typeof Node produced in actual iframe");
        assert_false(actualNode === null,
            "Node produced in actual iframe was null");
        assert_equals(typeof expectedNode, "object",
            "typeof Node produced in expected iframe");
        assert_false(expectedNode === null,
            "Node produced in expected iframe was null");

        for (var k = 0; k < actualRoots.length; k++) {
            assertNodesEqual(actualRoots[k], expectedRoots[k], k ? "moved node's tree root" : "range's tree root");
        }

        if (detached) {
            // No further tests we can do
            return;
        }

        assert_equals(actualRange.startOffset, expectedRange.startOffset,
            "Unexpected startOffset after insertNode()");
        assert_equals(actualRange.endOffset, expectedRange.endOffset,
            "Unexpected endOffset after insertNode()");
        // How do we decide that the two nodes are equal, since they're in
        // different trees?  Since the DOMs are the same, it's enough to check
        // that the index in the parent is the same all the way up the tree.
        // But we can first cheat by just checking they're actually equal.
        assert_true(actualRange.startContainer.isEqualNode(expectedRange.startContainer),
            "Unexpected startContainer after insertNode(), expected " +
            expectedRange.startContainer.nodeName.toLowerCase() + " but got " +
            actualRange.startContainer.nodeName.toLowerCase());
        var currentActual = actualRange.startContainer;
        var currentExpected = expectedRange.startContainer;
        var actual = "";
        var expected = "";
        while (currentActual && currentExpected) {
            actual = indexOf(currentActual) + "-" + actual;
            expected = indexOf(currentExpected) + "-" + expected;

            currentActual = currentActual.parentNode;
            currentExpected = currentExpected.parentNode;
        }
        actual = actual.substr(0, actual.length - 1);
        expected = expected.substr(0, expected.length - 1);
        assert_equals(actual, expected,
            "startContainer superficially looks right but is actually the wrong node if you trace back its index in all its ancestors (I'm surprised this actually happened");
    });
    positionTests[i][j].done();
}

testRanges.unshift('"detached"');

var iStart = 0;
var iStop = 1;
var jStart = 0;
var jStop = 1;

if (/subtest=[0-9]+,[0-9]+/.test(location.search)) {
    var matches = /subtest=([0-9]+),([0-9]+)/.exec(location.search);
    iStart = Number(matches[1]);
    iStop = Number(matches[1]) + 1;
    jStart = Number(matches[2]) + 0;
    jStop = Number(matches[2]) + 1;
}

var domTests = [];
var positionTests = [];
for (var i = iStart; i < iStop; i++) {
    domTests[i] = [];
    positionTests[i] = [];
    for (var j = jStart; j < jStop; j++) {
        domTests[i][j] = async_test(i + "," + j + ": resulting DOM for range " + testRangesShort[i] + ", node " + testNodesShort[j]);
        positionTests[i][j] = async_test(i + "," + j + ": resulting range position for range " + testRangesShort[i] + ", node " + testNodesShort[j]);
    }
}

var actualIframe = document.createElement("iframe");
actualIframe.style.display = "none";
document.body.appendChild(actualIframe);

var expectedIframe = document.createElement("iframe");
expectedIframe.style.display = "none";
document.body.appendChild(expectedIframe);

var referenceDoc = document.implementation.createHTMLDocument("");
referenceDoc.removeChild(referenceDoc.documentElement);

actualIframe.onload = function() {
    expectedIframe.onload = function() {
        for (var i = iStart; i < iStop; i++) {
            for (var j = jStart; j < jStop; j++) {
                testInsertNode(i, j);
            }
        }
    }
    expectedIframe.src = "Range-test-iframe.html";
    referenceDoc.appendChild(actualIframe.contentDocument.documentElement.cloneNode(true));
}
actualIframe.src = "Range-test-iframe.html";
</script>
